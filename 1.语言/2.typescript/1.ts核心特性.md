[](https://juejin.cn/post/6844904182843965453)

1.基础类型
    1.boolean
    2.number
    3.string
    4.array // number[] Array<number>
    5.enum  // enum Direction { Up = 1, Down, } 不设默认值从0起自增
    6.any  
```ts
// 任何类型的值分配给 any 类型的变量
let obj: any = { x: 0 };
// 任何类型的变量可以用 any 类型的值来赋值
const n: number = obj;
```
    7.unknown // 所有类型的值都可以赋值给 unknown类型变量，unknown类型变量可以赋值给unknow any类型变量
```ts
// 任何类型的值分配给 unknown 类型的变量
let value: unknown;
value = true; // OK
// any 与 unknow类型的变量可以用 unknown 类型的值来赋值
let value: unknown;
let value1: unknown = value; // OK
let value2: any = value; // OK
// any 类型允许所有更改的默认设置，unknown 类型禁止任何更改
value.foo.bar; // Error
```
    8.tuple
```ts
let tupleType: [string, boolean];
tupleType = ["Semlinker", true];
console.log(tupleType[0]); // Semlinker
console.log(tupleType[1]); // true
```
    9.void 
    10.undefined
    11.null
    12.never
```ts
type Foo = string | number;
function controlFlowAnalysisWithNever(foo: Foo) {
  if (typeof foo === "string") { // 这里 foo 被收窄为 string 类型
  } else if (typeof foo === "number") { // 这里 foo 被收窄为 number 类型
  } else {
    const check: never = foo; // foo 在这里是 never
  }
}
// 如果将 Foo 增加一个类型，而忘记修改分支逻辑,将导致最后没有收窄为never 类型，开发者得到编译错误的提示
```

2.类型断言
    1.尖括号语法
```ts
let someValue: any = "this is a string";
let strLength: number = (<string>someValue).length;
```
    2.as 语法
```ts
let someValue: any = "this is a string";
let strLength: number = (someValue as string).length;
```

3.类型守卫
